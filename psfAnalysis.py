import os
import re
import numpy as np
from  numpy.linalg import lstsq
import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf

"""
Take in the table of psf stars generated by ViewSodTemplate psf, and a 
raw ANU format photometry file.

Match the psf stars to stars in the photometry file, and output a lightcurve
file for each star, and a summary file for the whole set.
"""

def psfAnalysisDriver(field, psfFileName, photFileDir, outputLcPrefix, outputSummaryName, sigCutSummaryName, wsSummaryName, Plot=True):
    
    psfData = np.loadtxt(psfFileName, skiprows=1)

    # find the set of tiles referenced in psfFile, and their corresponding photometry files

    psfTiles = psfData[:, 0]

    uniqueTiles = np.unique(psfTiles)

    bailout = False
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        if not os.access(photFileName, os.F_OK):
            print photFileName + ' not found'
            bailout = True

    if bailout:
        return
    
    # process the photometry files


    Initialized = False
    lcListAll = list()
    
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        lcTmp, lcListX = psfAnalysis(psfFileName, photFileName, outputLcPrefix, outputSummaryName)
        # flatten lclistX here, append individuals to lcListAll
        if type(lcListX[0]) == str:   # lcListX is the 5 items for a single lightcurve
            FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB = lcListX
            lcListAll.append([FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wcCoeffB])
        else:                         # lcListX is a list of 5 item lists
            for l in lcListX:
                FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB = l
                lcListAll.append([FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB])
       
        if not Initialized:
            lcAll = lcTmp
            Initialized = True
        else:
            lcAll = np.append(lcAll, lcTmp, axis=0)

    # Calculate 2.5 sigma cuts

    (tobs, rsigcut, bsigcut) = psfStats(lcAll, sigCutSummaryName)

    # Calculate WS shifts in per-obs magnitude calibrations

    deltaRmag, deltaBmag = calcWSshift(lcListAll, outputSummaryName, tobs, rsigcut, bsigcut)

    Fout = open(wsSummaryName, 'w')
    
    print >>Fout, '# t dr db'
    for (i, dr) in enumerate(deltaRmag):
        print >>Fout, tobs[i], dr, deltaBmag[i]

    Fout.close()

    if Plot:
        plotFileName = outputLcPrefix + '_plt.pdf'
        graphicsPdf = matplotlib.backends.backend_pdf.PdfPages(plotFileName)

        fig=plt.figure()
        plt.subplot(211)
        plt.title('2.5 sigma cut levels')
        plt.plot(tobs, rsigcut, 'r.')
        plt.plot(tobs, -rsigcut, 'r.')
        plt.ylim(-0.5, 0.5)
        plt.subplot(212)
        plt.plot(tobs, bsigcut, 'b.')
        plt.plot(tobs, -bsigcut, 'b.')
        plt.ylim(-0.5, 0.5)
        graphicsPdf.savefig(fig)
        plt.close(fig)

        # Now plot the accumulated light curves

        for lc in lcListAll:
            FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB = lc
            lcPlot(FlcName, lcrTemplate, lcbTemplate, tTemplate, tobs, rsigcut, bsigcut, graphicsPdf)

        graphicsPdf.close()
    

def psfAnalysis(psfFileName, photFileName, outputLcPrefix, outputSummaryName):

    Fpsf = open(psfFileName)
    psfLine = Fpsf.readline()
    templateStr = psfLine.split()
    templateObs = int(templateStr[0])
    Fpsf.close()
    
    psfData = np.loadtxt(psfFileName, skiprows=1)

    photData = np.loadtxt(photFileName, delimiter=';', usecols=(2,3,4,9,10,24,25,5))

    Fsummary = open(outputSummaryName, 'a+')
    print >>Fsummary, '# tile seq Mag0 Mag1 ngood lcrMedian lcrStdev lcbMedian lcbStdev wsCoeff0 wsCoeff1'
    
    photTile = np.fix(photData[:,0])
    photSeq = np.fix(photData[:,1])

    nPsf = psfData.shape[0]

    Initialized = False

    for i in range(nPsf):
        psfStar = psfData[i, :]
        psfStarTile = int(psfStar[0])
        psfStarSeq = int(psfStar[1])
        psfStarMag0 = float(psfStar[2])/1000.
        psfStarMag1 = float(psfStar[4])/1000.
        psfPhotIdx = np.where((photTile==psfStarTile) & (photSeq==psfStarSeq))
        psfPhotLc = photData[psfPhotIdx[0],:]
        nLcPts = psfPhotLc.shape[0]
        if nLcPts > 0:
            time = psfPhotLc[:,2]
            rmag = psfPhotLc[:,3]
            rerr = psfPhotLc[:,4]
            bmag = psfPhotLc[:,5]
            berr = psfPhotLc[:,6]
            obsid = psfPhotLc[:,7]

            # determine good points
            igood = np.where((rmag > -15) & (bmag > -15) & (rmag <= -2) & (bmag <= -2) & (rerr < 0.2) & (berr < 0.2))
            ngood = len(igood[0])

            # keep only good points
            time = time[igood]
            rmag = rmag[igood]
            rerr = rerr[igood]
            bmag = bmag[igood]
            berr = berr[igood]
            obsid = obsid[igood]
            
            lcrMedian = np.median(rmag)
            lcrStdev = np.std(rmag)
            lcbMedian = np.median(bmag)
            lcbStdev = np.std(bmag)
            templateIdx = np.where(obsid==templateObs)
            lcrTemplate = rmag[templateIdx]
            lcbTemplate = bmag[templateIdx]
            tTemplate = time[templateIdx]
            rdev = rmag - lcrTemplate
            bdev = bmag - lcbTemplate

            wsCoeffR, wsCoeffB = fitWS(rdev, rerr, bdev, berr)
            
            print >>Fsummary, psfStarTile, psfStarSeq, psfStarMag0, psfStarMag1, ngood, lcrMedian, lcrStdev, lcbMedian, lcbStdev, wsCoeffR[0], wsCoeffR[1], wsCoeffB[0], wsCoeffB[1]
            FlcName = '%s_%d_%d.dat' % (outputLcPrefix, psfStarTile, psfStarSeq)
            Flc = open(FlcName, 'w')
            print >>Flc, '# t rmag rerr bmag berr rdev bdev'
            
            for i in range(ngood):
                print >>Flc, time[i], rmag[i], rerr[i], bmag[i], berr[i], rdev[i], bdev[i]
            Flc.close()

            # append to output array
            lcTmp = np.zeros((ngood, 7))
            lcTmp[:,0] = time
            lcTmp[:,1] = rmag
            lcTmp[:,2] = rerr
            lcTmp[:,3] = bmag
            lcTmp[:,4] = berr
            lcTmp[:,5] = rdev
            lcTmp[:,6] = bdev
            if not Initialized:
                lcOut = lcTmp
                lcList = list([[FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB]])
                Initialized = True
            else:
                lcOut = np.append(lcOut, lcTmp, axis=0)
                lcList.append(list([FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB]))

    Fsummary.close()
    return lcOut, lcList

def fitWS(rdev, rerr, bdev, berr):

    bMinusr = bdev - rdev
    wsCoeffR = np.polyfit(bMinusr, rdev, 1)
    wsCoeffB = np.polyfit(bMinusr, bdev, 1)
    
    return wsCoeffR, wsCoeffB

def calcWSshift(lcListAll, wsSummaryName, tobs, rsigcut, bsigcut):

    wsShiftR = np.zeros(len(tobs))
    wsShiftB = np.zeros(len(tobs))
    nptsWsShiftR = np.zeros(len(tobs))
    nptsWsShiftB = np.zeros(len(tobs))
    
    FlcNameRe = re.compile('.*_(\d+)_(\d+).dat')
    for lc in lcListAll:
        FlcName, lcrTemplate, lcbTemplate, tTemplate, wsCoeffR, wsCoeffB = lc
        matchName = FlcNameRe.match(FlcName)
        thisTile = int(matchName.group(1))
        thisSeq = int(matchName.group(2))
        lcDat = np.loadtxt(FlcName)
        time = lcDat[:,0]
        rdev = lcDat[:,5]
        bdev = lcDat[:,6]

        ws0r = wsCoeffR[0]
        ws1r = wsCoeffR[1]
        ws0b = wsCoeffB[0]
        ws1b = wsCoeffB[1]

        for (i, t) in enumerate(time):
            idt = np.where(tobs==t)
            if np.abs(bdev[i]) < bsigcut[idt]:
                wsPoly = np.array([ws0b, ws1b])
                wsShiftB[idt] += np.polyval(wsPoly, bdev[i]-rdev[i])
                nptsWsShiftB[idt] += 1 
            if np.abs(rdev[i]) < rsigcut[idt]:
                wsPoly = np.array([ws0r, ws1r])
                wsShiftR[idt] += np.polyval(wsPoly, bdev[i]-rdev[i])
                nptsWsShiftR[idt] += 1 

    return wsShiftR/nptsWsShiftR, wsShiftB/nptsWsShiftB

def psfStats(lcAll, sigCutSummaryName):
    

    times = np.unique(lcAll[:,0])
    ntimes = len(times)
    tobs = np.zeros((ntimes))
    rsigcut = np.zeros((ntimes))
    bsigcut = np.zeros((ntimes))
    
    FsigCutSummary= open(sigCutSummaryName, 'w')

    
    # Do the Dave Bennett sigma clipping stats
    
    for (i,t) in enumerate(times):
        tobs[i] = t
        idx = np.where(lcAll[:,0]==t)
        rerr = lcAll[idx,2]
        rdev = lcAll[idx,5]
        berr = lcAll[idx,3]
        bdev = lcAll[idx,6]
        rwt = 1./(rerr**2 + 0.01**2)
        rwtvar = np.mean((rdev - rdev.mean())**2*rwt)/np.mean(rwt)
        rsigcut[i] = 2.5*np.sqrt(rwtvar)
        bwt = 1./(berr**2 + 0.01**2)
        bwtvar = np.mean((bdev - bdev.mean())**2*bwt)/np.mean(bwt)
        bsigcut[i] = 2.5*np.sqrt(bwtvar)

    # with the sigma clipping thresholds in hand, calculate, for the valid psf set at each
    # time, the weighted means of rdev and bdev.  If we're doing things correctly, these should
    # all be close to zero

    print >>FsigCutSummary, '# tobs rsigcut bsigcut rdevWtdMean bdevWtdMean numr numb'
    
    for (i,t) in enumerate(times):
        tobs[i] = t
        idx = np.where(lcAll[:,0]==t)
        rerr = lcAll[idx,2]
        rdev = lcAll[idx,5]
        rwt = 1./(rerr**2 + 0.01**2)
        idrgood = np.where(np.abs(rdev -rdev.mean()) < rsigcut[i])
        rdevWtdMean = np.sum(rdev[idrgood]*rwt[idrgood])/np.sum(rwt[idrgood])
        
        berr = lcAll[idx,3]
        bdev = lcAll[idx,6]
        bwt = 1./(berr**2 + 0.01**2)
        idbgood = np.where(np.abs(bdev - bdev.mean()) < bsigcut[i])
        bdevWtdMean = np.sum(bdev[idbgood]*bwt[idbgood])/np.sum(bwt[idbgood])

        print >>FsigCutSummary, tobs[i], rsigcut[i], bsigcut[i], rdevWtdMean, bdevWtdMean, len(idrgood[0]), len(idbgood[0])

    FsigCutSummary.close()
    
    return tobs, rsigcut, bsigcut

def lcPlot(lcFileName, lcrTemplate, lcbTemplate, tTemplate, tSigcut, rSigcut, bSigcut, pdf):

    lcDat = np.loadtxt(lcFileName)
    time = lcDat[:,0]
    rmag = lcDat[:,1]
    bmag = lcDat[:,3]

    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((rmag[i]>lcrTemplate+rSigcut[idx]) | (rmag[i]<lcrTemplate-rSigcut[idx])):
            plt.plot(t-time[0], rmag[i], 'k.')
        else:
            plt.plot(t-time[0], rmag[i], 'r.')
        
    
    fig=plt.figure()
    plt.subplot(311)
    plt.title('%s' % (lcFileName))
    
    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((rmag[i]>lcrTemplate+rSigcut[idx]) | (rmag[i]<lcrTemplate-rSigcut[idx])):
            plt.plot(t-time[0], rmag[i], 'cx')
        else:
            plt.plot(t-time[0], rmag[i], 'r.')
    plt.plot(tTemplate-time[0], lcrTemplate, 'g*', markersize=15)
    
    plt.subplot(312)
    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((bmag[i]>lcbTemplate+bSigcut[idx]) | (bmag[i]<lcbTemplate-bSigcut[idx])):
            plt.plot(t-time[0], bmag[i], 'cx')
        else:
            plt.plot(t-time[0], bmag[i], 'b.')
    
    plt.plot(tTemplate-time[0], lcbTemplate, 'g*', markersize=15)
    plt.subplot(313)
    plt.plot(bmag - rmag, bmag, 'b.')
    plt.plot(lcbTemplate - lcrTemplate, lcbTemplate, 'g*', markersize=15)
    pdf.savefig(fig)
    plt.close(fig)
