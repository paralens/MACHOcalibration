import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf

"""
Take in the table of psf stars generated by ViewSodTemplate psf, and a 
raw ANU format photometry file.

Match the psf stars to stars in the photometry file, and output a lightcurve
file for each star, and a summary file for the whole set.
"""

def psfAnalysisDriver(field, psfFileName, photFileDir, outputLcPrefix, outputSummaryName):
    
    psfData = np.loadtxt(psfFileName, skiprows=1)

    # find the set of tiles referenced in psfFile, and their corresponding photometry files

    psfTiles = psfData[:, 0]

    uniqueTiles = np.unique(psfTiles)

    bailout = False
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        if not os.access(photFileName, os.F_OK):
            print photFileName + ' not found'
            bailout = True

    if bailout:
        return
    
    # process the photometry files

    plotFileName = outputLcPrefix + '_plt.pdf'
    graphicsPdf = matplotlib.backends.backend_pdf.PdfPages(plotFileName)

    Initialized = False
    
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        lcTmp, lcList = psfAnalysis(psfFileName, photFileName, outputLcPrefix, outputSummaryName)
        if not Initialized:
            lcAll = lcTmp
            lcListAll = lcList
            Initialized = True
        else:
            lcAll = np.append(lcAll, lcTmp, axis=0)
            lcListAll.append(lcList)

    
    # Do the Dave Bennett statistics

    times = np.unique(lcAll[:,0])
    ntimes = len(times)
    tobs = np.zeros((ntimes))
    rsigcut = np.zeros((ntimes))
    bsigcut = np.zeros((ntimes))
    
    Fsummary = open(outputSummaryName, 'a+')

    print >>Fsummary, '# t, r2.5sig b2.5sig'
    
    for (i,t) in enumerate(times):
        tobs[i] = t
        idx = np.where(lcAll[:,0]==t)
        print 'matching times at time ', t, len(idx[0])
        rerr = lcAll[idx,2]
        rdev = lcAll[idx,5]
        berr = lcAll[idx,3]
        bdev = lcAll[idx,6]
        rwt = 1./(rerr**2 + 0.01**2)
        rwtvar = np.mean((rdev - rdev.mean())**2*rwt)/np.mean(rwt)
        rsigcut[i] = 2.5*np.sqrt(rwtvar)
        bwt = 1./(berr**2 + 0.01**2)
        bwtvar = np.mean((bdev - bdev.mean())**2*bwt)/np.mean(bwt)
        bsigcut[i] = 2.5*np.sqrt(bwtvar)
        print >>Fsummary, tobs[i], rsigcut[i], bsigcut[i]

    Fsummary.close()
    
    fig=plt.figure()
    plt.subplot(211)
    plt.title('2.5 sigma cut levels')
    plt.plot(tobs, rsigcut, 'r.')
    plt.plot(tobs, -rsigcut, 'r.')
    plt.ylim(-0.5, 0.5)
    plt.subplot(212)
    plt.plot(tobs, bsigcut, 'b.')
    plt.plot(tobs, -bsigcut, 'b.')
    plt.ylim(-0.5, 0.5)
    graphicsPdf.savefig(fig)
    plt.close(fig)

    # Now plot the accumulated light curves

    for lc in lcListAll:
        if type(lc[0]) == str:
            FlcName, lcrTemplate, lcbTemplate, tTemplate = lc
            lcPlot(FlcName, lcrTemplate, lcbTemplate, tTemplate, tobs, rsigcut, bsigcut, graphicsPdf)
        else:
            for l in lc:
                FlcName, lcrTemplate, lcbTemplate, tTemplate = l
                lcPlot(FlcName, lcrTemplate, lcbTemplate, tTemplate, tobs, rsigcut, bsigcut, graphicsPdf)
                
            
        lcPlot(FlcName, lcrTemplate, lcbTemplate, tTemplate, tobs, rsigcut, bsigcut, graphicsPdf)
    

    graphicsPdf.close()
    

def psfAnalysis(psfFileName, photFileName, outputLcPrefix, outputSummaryName):

    Fpsf = open(psfFileName)
    psfLine = Fpsf.readline()
    templateStr = psfLine.split()
    templateObs = int(templateStr[0])
    Fpsf.close()
    
    psfData = np.loadtxt(psfFileName, skiprows=1)

    photData = np.loadtxt(photFileName, delimiter=';', usecols=(2,3,4,9,10,24,25,5))

    Fsummary = open(outputSummaryName, 'a+')

    photTile = np.fix(photData[:,0])
    photSeq = np.fix(photData[:,1])

    nPsf = psfData.shape[0]

    Initialized = False

    for i in range(nPsf):
        psfStar = psfData[i, :]
        psfStarTile = int(psfStar[0])
        psfStarSeq = int(psfStar[1])
        psfStarMag0 = float(psfStar[2])/1000.
        psfStarMag1 = float(psfStar[4])/1000.
        psfPhotIdx = np.where((photTile==psfStarTile) & (photSeq==psfStarSeq))
        psfPhotLc = photData[psfPhotIdx[0],:]
        nLcPts = psfPhotLc.shape[0]
        if nLcPts > 0:
            time = psfPhotLc[:,2]
            rmag = psfPhotLc[:,3]
            rerr = psfPhotLc[:,4]
            bmag = psfPhotLc[:,5]
            berr = psfPhotLc[:,6]
            obsid = psfPhotLc[:,7]
            igood = np.where((rmag > -15) & (bmag > -15) & (rmag <= -2) & (bmag <= -2) & (rerr < 0.2) & (berr < 0.2))
            ngood = len(igood[0])
            lcrMedian = np.median(rmag[igood])
            lcrStdev = np.std(rmag[igood])
            lcbMedian = np.median(bmag[igood])
            lcbStdev = np.std(bmag[igood])
            templateIdx = np.where(obsid==templateObs)
            lcrTemplate = rmag[templateIdx]
            lcbTemplate = bmag[templateIdx]
            tTemplate = time[templateIdx]
            rdev = rmag - lcrTemplate
            bdev = bmag - lcbTemplate

            print >>Fsummary, psfStarTile, psfStarSeq, psfStarMag0, psfStarMag1, ngood, lcrMedian, lcrStdev, lcbMedian, lcbStdev
            FlcName = '%s_%d_%d.dat' % (outputLcPrefix, psfStarTile, psfStarSeq)
            Flc = open(FlcName, 'w')
            print >>Flc, '# t rmag rerr bmag berr rdev bdev'

            igood = igood[0]
            ngood = len(igood)
            
            for i in igood:
                print >>Flc, time[i], rmag[i], rerr[i], bmag[i], berr[i], rdev[i], bdev[i]
            Flc.close()

            # append to output array
            lcTmp = np.zeros((ngood, 7))
            lcTmp[:,0] = time[igood]
            lcTmp[:,1] = rmag[igood]
            lcTmp[:,2] = rerr[igood]
            lcTmp[:,3] = bmag[igood]
            lcTmp[:,4] = berr[igood]
            lcTmp[:,5] = rdev[igood]
            lcTmp[:,6] = bdev[igood]
            if not Initialized:
                lcOut = lcTmp
                lcList = list([[FlcName, lcrTemplate, lcbTemplate, tTemplate]])
                Initialized = True
            else:
                lcOut = np.append(lcOut, lcTmp, axis=0)
                lcList.append(list([FlcName, lcrTemplate, lcbTemplate, tTemplate]))

    Fsummary.close()
    return lcOut, lcList

def lcPlot(lcFileName, lcrTemplate, lcbTemplate, tTemplate, tSigcut, rSigcut, bSigcut, pdf):

    lcDat = np.loadtxt(lcFileName)
    time = lcDat[:,0]
    rmag = lcDat[:,1]
    bmag = lcDat[:,3]

    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((rmag[i]>lcrTemplate+rSigcut[idx]) | (rmag[i]<lcrTemplate-rSigcut[idx])):
            plt.plot(t-time[0], rmag[i], 'k.')
        else:
            plt.plot(t-time[0], rmag[i], 'r.')
        
    
    fig=plt.figure()
    plt.subplot(311)
    plt.title('%s' % (lcFileName))
    
    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((rmag[i]>lcrTemplate+rSigcut[idx]) | (rmag[i]<lcrTemplate-rSigcut[idx])):
            plt.plot(t-time[0], rmag[i], 'cx')
        else:
            plt.plot(t-time[0], rmag[i], 'r.')
    plt.plot(tTemplate-time[0], lcrTemplate, 'g*', markersize=15)
    
    plt.subplot(312)
    for (i,t) in enumerate(time):
        idx = np.where(tSigcut==t)[0]
        if ((bmag[i]>lcbTemplate+bSigcut[idx]) | (bmag[i]<lcbTemplate-bSigcut[idx])):
            plt.plot(t-time[0], bmag[i], 'cx')
        else:
            plt.plot(t-time[0], bmag[i], 'b.')
    
    plt.plot(tTemplate-time[0], lcbTemplate, 'g*', markersize=15)
    plt.subplot(313)
    plt.plot(bmag - rmag, bmag, 'b.')
    plt.plot(lcbTemplate - lcrTemplate, lcbTemplate, 'g*', markersize=15)
    pdf.savefig(fig)
    plt.close(fig)
