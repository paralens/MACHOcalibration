import os
import re
import numpy as np
from  numpy.linalg import lstsq
import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf
import lcScoreBoard 
"""
Take in the table of psf stars generated by ViewSodTemplate psf, and a 
raw ANU format photometry file.

Match the psf stars to stars in the photometry file, and output a lightcurve
file for each star, and a summary file for the whole set.
"""

def psfAnalysisDriver(field, psfFileName, photFileDir, outputLcPrefix, outputSummaryName, sigCutSummaryName, wsSummaryName, Plot=True):
    
    Fpsf = open(psfFileName)
    psfLine = Fpsf.readline()
    templateStr = psfLine.split()
    templateObs = int(templateStr[0])
    Fpsf.close()

    psfData = np.loadtxt(psfFileName, skiprows=1)

    # find the set of tiles referenced in psfFile, and their corresponding photometry files

    psfTiles = psfData[:, 0]

    uniqueTiles = np.unique(psfTiles)

    bailout = False
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        if not os.access(photFileName, os.F_OK):
            print(photFileName + ' not found')
            bailout = True

    if bailout:
        return
    
    # load the photometry files

    lcsb = lcScoreBoard.LcScoreBoard()
    
    Initialized = False
    lcListAll = list()
    
    for tile in uniqueTiles:
        photFileName = '%s/F_%d.%d' % (photFileDir, field, tile)
        loadPsfLcs(lcsb, psfFileName, photFileName, outputLcPrefix, outputSummaryName)

    # set the template obs - calculates rdev, bdev

    lcsb.setTemplateObs(templateObs)

    lcsb.filter2pt5Sigma()

    lcsb.filterDDB()

    lcsb.calcWsCoeffs()

    lcsb.calcWsShift()

    return lcsb
    
def loadPsfLcs(lcsb, psfFileName, photFileName, outputLcPrefix, outputSummaryName):


    psfData = np.loadtxt(psfFileName, skiprows=1)

    photData = np.loadtxt(photFileName, delimiter=';', usecols=(2,3,4,9,10,24,25,5))

    photTile = np.fix(photData[:,0])
    photSeq = np.fix(photData[:,1])

    nPsf = psfData.shape[0]

    for i in range(nPsf):
        psfStar = psfData[i, :]
        psfStarTile = int(psfStar[0])
        psfStarSeq = int(psfStar[1])
        psfPhotIdx = np.where((photTile==psfStarTile) & (photSeq==psfStarSeq))
        psfPhotLc = photData[psfPhotIdx[0],:]
        nLcPts = psfPhotLc.shape[0]
        if nLcPts > 0:
            time = psfPhotLc[:,2]
            rmag = psfPhotLc[:,3]
            rerr = psfPhotLc[:,4]
            bmag = psfPhotLc[:,5]
            berr = psfPhotLc[:,6]
            obsid = psfPhotLc[:,7]

            # determine good points
            igood = np.where((rmag > -15) & (bmag > -15) & (rmag <= -2) & (bmag <= -2) & (rerr < 0.2) & (berr < 0.2))
            ngood = len(igood[0])

            # keep only good points
            time = time[igood]
            rmag = rmag[igood]
            rerr = rerr[igood]
            bmag = bmag[igood]
            berr = berr[igood]
            obsid = obsid[igood]

            lcData = np.stack((time, rmag, rerr, bmag, berr, obsid),axis=1)
            lcsb.addLC(i, lcData)

            FlcName = '%s_%d_%d.dat' % (outputLcPrefix, psfStarTile, psfStarSeq)
            Flc = open(FlcName, 'w')
            print('# t obsid rmag rerr bmag berr', file=Flc)

            for i in range(ngood):
                print(time[i], obsid[i], rmag[i], rerr[i], bmag[i], berr[i], file=Flc)
            Flc.close()
